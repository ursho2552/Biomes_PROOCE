function [ bmu2 ] = find_2_bmu( data, class, weights, classes, dist_metric)
%data is an observation with only the samples and class
%weights denotes the matrix of weights of all neurons
%classes is a vector containing the labels of the neurons
%data should only have the species occurence data and the class
%classes denotes the available classes

%{
Parameters:
    data (matrix): Features of one observation
    class (vector): Class label of the observation
    weights (matrix) : Weights of the trained neurons
    classes (vector): Vector containing the class labels for each observations
    dist_metric (str): Metric used to calculate distance between neurons
 
 Output:
    bmu2 (float): Quantization error based on the average norm of the differences
    between the obervation and the neuron weights across all neurons
    te (float): Topological error
    total_error (float): Sum of quantization and topological error
%}


new_data = data; %copy occurrence data
 
 
ind = find(classes == class); %find the index in weights 
                                         %that contains the BMU
[m n] = size(weights);
rest_BMU = ones(m,n+1)*NaN;

for i = 1:m
rest_BMU(i,:) = [weights(i,:), classes(i)]; %rest_BMU contains all weights and labels of 
                          %neurons that are not BMU  
                          
end

rest_BMU(ind,:) = [];     %delete BMU, so you only have the non-BMU  

sum_dist = ones( length(rest_BMU(:,end)),2 )*NaN;
for i =1:length(rest_BMU(:,end))
    if(strcmp(dist_metric,'dist'))
        dist = new_data - rest_BMU(i,1:end-1);
        dist2 = dist.^2;
        dist3 = sum(dist2,2);
        dist4 = sqrt(dist3);
    elseif(strcmp(dist_metric,'mandist'))
        dist= abs(new_data - rest_BMU(i,1:end-1));
        dist3 = sum(dist,2);
        dist4 = dist3;
    end
    sum_dist(i,1) = dist4;
    sum_dist(i,2) = rest_BMU(i,end);

end

%need to check if there's only one BMU, if not, choose one at random
pre_bmu2 =   sum_dist(find(sum_dist(:,1) == min(sum_dist(:,1))),2);
if (size(pre_bmu2) ~= [1 1]) %should always be size [1 1] otherwise somthing is wrong!!!
    fprintf('too many \n')
end
bmu2 = datasample(pre_bmu2,1); %can be done like this. if there is only one
%element then it will be chosen, otherwise a random second BMU is chosen.



   

end

